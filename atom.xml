<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangpifu.github.io</id>
    <title>wangpifu</title>
    <updated>2020-05-01T01:20:47.892Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangpifu.github.io"/>
    <link rel="self" href="https://wangpifu.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wangpifu.github.io/images/avatar.png</logo>
    <icon>https://wangpifu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, wangpifu</rights>
    <entry>
        <title type="html"><![CDATA[cpu affinity 亲和性]]></title>
        <id>https://wangpifu.github.io/post/cpu-affinity-qin-he-xing/</id>
        <link href="https://wangpifu.github.io/post/cpu-affinity-qin-he-xing/">
        </link>
        <updated>2020-04-29T12:49:24.000Z</updated>
        <content type="html"><![CDATA[<p>cpu affinity 就是让某个进程/线程绑定在某个cpu(core)上，使其尽量长时间的运行而不被迁移到其他core上的倾向性。 Linux kernel提供了两个api来修改或查看某个进程/线程的亲和性：<br>
<code>int sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);</code><br>
<code>int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);</code><br>
如果pid是0，那么默认是当前thread。<br>
cpu_set_t 是一个掩码数组，共1024位，每一位对应一个core，以下宏是对这个掩码进行操作的：</p>
<pre><code>void CPU_ZERO (cpu_set_t *set)
这个宏对 CPU 集 set 进行初始化，将其设置为空集。
void CPU_SET (int cpu, cpu_set_t *set)
这个宏将 cpu 加入 CPU 集 set 中。
void CPU_CLR (int cpu, cpu_set_t *set)
这个宏将 cpu 从 CPU 集 set 中删除。
int CPU_ISSET (int cpu, const cpu_set_t *set)
如果 cpu 是 CPU 集 set 的一员，这个宏就返回一个非零值（true），否则就返回零（false）。
</code></pre>
<p>我看到很多人说对于thread我们用pthread_setaffinity_np， 对于process我们才用sched_setafinity.于是我仔细的看了一下。首先，sched_setaffinity的man page上写的是</p>
<blockquote>
<p>A thread's CPU affinity mask determines the set of CPUs on which it is eligible to run</p>
</blockquote>
<p>当然它也写了</p>
<blockquote>
<p>(If you are using the POSIX threads API, then use pthread_setaffinity_np(3) instead of sched_setaffinity().)</p>
</blockquote>
<p>当我们使用</p>
<pre><code>int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);
int pthread_getaffinity_np(pthread_t thread, size_t cpusetsize, cpu_set_t *cpuset);
</code></pre>
<p>我们传入的是pthread_t. 而当我们使用<code>sched_setaffinity</code>时，我们传进去的可以是pid from <code>getpid()</code>,也可以是tid from <code>gettid()</code>.（对于单线程的进程，pid等于tid，对于多线程的进程，每个线程有不同的tid，但会有相同的pid。）pid_t 和pthread_t是不同的，pthread_t是同一个进程中各个线程之间的标识号，对于这个进程内是唯一的，而不同进程中，每个线程返回的pthread_t可能是一样的。而gettid是用来系统内各个线程间的标识符，由于linux采用轻量级进程实现的，它其实返回的应该是pid号。 还有需要注意的就是当你给一个线程设置了亲和性然后pthread_create 其他线程，其他线程会继承当前这个线程的亲和性。不过在我的工作范围内，sched_setaffinity 已经足够，因为线程的创建是固定的，我们也需要在创建后设置亲和性，所以不必担心亲和性的继承问题。</p>
<p>BTW: gettid() is not implemented in glibc, 所以我们需要用syscall去获取tid</p>
<pre><code class="language-c">pid_t getThreadId()
{
    return syscall(__NR_gettid);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ Multithreading programming 学习(1)]]></title>
        <id>https://wangpifu.github.io/post/c-multithreading-programming-xue-xi-1/</id>
        <link href="https://wangpifu.github.io/post/c-multithreading-programming-xue-xi-1/">
        </link>
        <updated>2020-04-29T11:17:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="thread-overview">Thread Overview</h1>
<p><img src="https://wangpifu.github.io/post-images/1588203959444.png" alt="" loading="lazy"><br>
Thread 是一段独立于其他代码的，由操作系统调度的指令。它能使用process的资源，但是可以独立的被OS调用。 它像是轻量级的process，但是创建比process快。 同时thread可以直接与同一process下其他thread通信。 而process之间用到PIPE,FIFO来发送短小高频的消息，适用于两个process之间。或者用共享内存以及socket来通信。</p>
<h2 id="pthread">Pthread</h2>
<h3 id="overview">Overview</h3>
<p>在c++11以前，c++没有很好的thread库支持，一般是通过系统的thread库来实现线程相关代码。Pthread即源于posix系统。代码基于c，对于其他操作系统不具有移植性。</p>
<h3 id="使用pthread">使用pthread</h3>
<p>对于posix系统，需要包含头文件<code>#include &lt;pthread.h&gt;</code> ，如果需要使用<code>semaphre</code>, 则需要<code>#include &lt;semaphore.h&gt;</code>。 在编译时，需要<code>g++ test.cpp -lpthread</code> 或者在cmake中定义<code>find_package(Threads REQUIRED)</code>。</p>
<h3 id="thread-creation">Thread Creation</h3>
<h4 id="api">API</h4>
<pre><code>int pthread_create(pthread_t *thread,
              const pthread_attr_t *attr,
              void *(*start_routine)(void*), void *arg);
void pthread_exit(void *value_ptr);
int pthread_cancel(pthread_t thread);
int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
</code></pre>
<p><code>pthread_create</code> 创建一个新的线程并运行它.它能在代码的任何处被多次调用.<br>
<code>pthread_create</code> 的参数:<br>
<code>thread</code>:返回新 thread 的唯一标识.<br>
<code>attr</code>:设置 thread 的性质.NULL 为默认性质.<br>
<code>start_routine</code>: 新 thread 运行的函数指针.<br>
<code>arg</code>:传给 start_routine 的参数,必须强制转换成 void *.NULL 为没有参数传入.</p>
<h4 id="thread-attributes">Thread Attributes</h4>
<p><code>pthread_attr_init</code> 和 <code>pthread_attr_destroy</code> 被用来初始化/销毁 thread 性质对象. 如 detached or joinable state, scheduling policy.</p>
<h4 id="thread-binding">Thread Binding</h4>
<p>参见这篇文章<a href="https://wangpifu.github.io/post/cpu-affinity-qin-he-xing">cpu 亲和性</a></p>
<h3 id="thread-termination">Thread Termination</h3>
<p>Thread 有多种终止方式：</p>
<ul>
<li>线程从它的运行中正常放回.它的工作完成.</li>
<li>线程调用 <code>pthread_exit</code> 无论它的工作完成否.</li>
<li>线程被另外一个线程调用<code>pthread_cance</code>来取消.</li>
<li>整个<strong>进程</strong>都终止，如果任何线程调用了 <code>exec()</code> 或 <code>exit()</code>.</li>
<li><code>main()</code> 函数先完成,没有调用 <code>pthread_exit</code>.</li>
</ul>
<p><code>void pthread_exit(void * rval_ptr);</code><br>
函数说明：rval_ptr参数是线程结束时的返回值，可由其他函数如pthread_join()来获取。这个调用不关闭文件,在线程打开的任何文件在线程终止后将继续打开.</p>
<ul>
<li>如果 <code>main()</code>在它创建的 threads 之前终止,并没有显式的调用 pthread_exit(),所有创建的线程都将终止，因为<code>main()</code>结束,不再存在支持这些线程.</li>
<li>通过<code>main()</code>在最后调用 <code>pthread_exit()</code>, <code>main()</code>将阻塞并保持存活来支持它创建的线程运行直到它们完成.</li>
</ul>
<p><code>int pthread_cancel(pthread_t thread);</code><br>
函数说明：取消线程，该函数在其他线程中调用，用来强行杀死指定的线程。<br>
我从来没用过这个函数，似乎使用情况有些tricky，参见这篇<a href="https://blog.csdn.net/fozhishuiyue/article/details/98936578">博客</a>。另外我自己写了个程序试验了一下但是一直有segment fault TODO: 查明原因，深入理解一下。</p>
<h4 id="example-of-pthread-creationand-termination">Example of pthread creationand termination</h4>
<p>如果注释掉 <code>main()</code>中最后的 <code>pthread_exit(NULL);</code> ,那么它创建的线程将会完成不了所有的打印而被强制退出.</p>
<pre><code class="language-c++">#include &lt;pthread.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

void *ThreadProc(void *param) {
  int id;
  id = *(static_cast&lt;int *&gt;(param));
  for (int i = 0; i &lt; 10; ++i) {
    if(id == 1 &amp;&amp; i == 8)
    { 
        // for pthread_t 1, it will only print to 7 and then terminate.
        pthread_exit(NULL);
    }
    printf(&quot;thread %d: run %d \n&quot;, id, i);
  }
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  const int kNumThreads = 4;
  pthread_t threads[kNumThreads];
  int thread_ids[kNumThreads];
  for (int i = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    int rt = pthread_create(&amp;threads[i], NULL, ThreadProc,
                            static_cast&lt;void *&gt;(&amp;thread_ids[i]));
    if (rt) {
      printf(&quot;ERROR: pthread_create failed, rt=%d\n&quot;, rt);
      exit(1);
    }
  }
  pthread_exit(NULL);
}
</code></pre>
<h3 id="threads-joining-and-detaching">Threads joining and detaching</h3>
<h4 id="api-2">API</h4>
<pre><code class="language-c++">int pthread_join(pthread_t thread, void **value_ptr);
int pthread_detach(pthread_t thread);
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
//PTHREAD_CREATE_DETACHED 分离
//PTHREAD_CREATE_JOINABLE 不分离
</code></pre>
<h4 id="joining">Joining</h4>
<p><img src="https://wangpifu.github.io/post-images/1588262396632.png" alt="" loading="lazy"><br>
joining 是用来同步不同线程的方法之一</p>
<ul>
<li><code>int pthread_join(pthread_t thread, void **value_ptr);</code> 将阻塞调用它的线程直到被指定的thread线程终止。</li>
<li>调用的线程能获取目标线程终止返回的 status 如果目标线程调用 <code>pthread_exit()</code></li>
<li>当一个线程被创建,它的属性之一是它是否可以 join.只有创建的能被 join 的线程才能被 join.如果线程线程以 detached 创建,它永远都不能被 join。</li>
</ul>
<h4 id="detaching">Detaching</h4>
<ul>
<li>pthread_detach() 可以将一个线程detach，即使它原先是以join位attribute建立的</li>
</ul>
<h4 id="example">Example</h4>
<pre><code class="language-c++">#include &lt;pthread.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

void *ThreadProc(void *param) {
  int id;
  id = *(static_cast&lt;int *&gt;(param));
  for (int i = 0; i &lt; 10; ++i) {
    printf(&quot;thread %d: run %d \n&quot;, id, i);
  }
  pthread_exit(param);
}

int main(int argc, char *argv[]) {
  const int kNumThreads = 4;
  pthread_t threads[kNumThreads];
  int thread_ids[kNumThreads];
  pthread_attr_t attr;

  pthread_attr_init(&amp;attr);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

  for (int i = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    int rt = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            static_cast&lt;void *&gt;(&amp;thread_ids[i]));
    if (rt) {
      printf(&quot;ERROR: pthread_create failed, rt=%d\n&quot;, rt);
      exit(1);
    }
  }
  for (int i = 0; i &lt; kNumThreads; ++i) {
    void *status;
    int rt = pthread_join(threads[i], &amp;status);
    if (rt) {
      printf(&quot;ERROR: pthread_join failed, rt=%d\n&quot;, rt);
      exit(1);
    }
    printf(&quot;completed join with thread %d having a status of %d\n&quot;
           , i, *static_cast&lt;int *&gt;(status));
  }
  pthread_exit(NULL);
}
</code></pre>
<h3 id="stack-management">Stack Management</h3>
<h4 id="api-3">API</h4>
<pre><code>int pthread_attr_getstacksize(const pthread_attr_t *restrict attr,
              size_t *restrict stacksize);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
int pthread_attr_getstackaddr(const pthread_attr_t *restrict attr,
              void **restrict stackaddr); // removed in POSIX.1-2008
int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr); 
int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);
int pthread_attr_getstack(const pthread_attr_t *attr,  void **stackaddr, size_t *stacksize);
int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
//功能：设置线程属性中栈尾的警戒区大小
int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize);
//功能：获取线程属性中栈尾的警戒区大小
</code></pre>
<p>每个线程都有各自独立的 stack, <code>pthread_attr_getstackaddr</code> 和 <code>pthread_attr_setstackaddr</code> 分别获取和设置线程的栈底地址. 在POSIX.1-2008被删除，需要使用新的api <code>pthread_attr_setstack</code>, <code>pthread_attr_getstack</code>.<code>get/setstacksize()</code>获取和设置stack的栈空间字节数。我们通过attr在<code>pthread_create()</code>传入</p>
<h4 id="example-2">example</h4>
<pre><code class="language-c++">#include &lt;pthread.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

pthread_attr_t attr;

void *ThreadProc(void *param) {
  int id;
  size_t thread_stack_size;
  id = *(static_cast&lt;int *&gt;(param));
  pthread_attr_getstacksize(&amp;attr, &amp;thread_stack_size);
  printf(&quot;thread %d: stack size = %d\n&quot;, id, thread_stack_size);
  for (int i = 0; i &lt; 10; ++i) {
    printf(&quot;thread %d: run %d \n&quot;, id, i);
  }
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  const int kNumThreads = 4;
  const int kThround = 1000;
  pthread_t threads[kNumThreads];
  int thread_ids[kNumThreads];
  size_t stack_size;

  pthread_attr_init(&amp;attr);
  pthread_attr_getstacksize(&amp;attr, &amp;stack_size);
  printf(&quot;Default stack size = %d\n&quot;, stack_size);
  stack_size = sizeof(double) * kThround * kThround;
  printf(&quot;Setting stack size = %d\n&quot;, stack_size);
  pthread_attr_setstacksize(&amp;attr, stack_size);
  for (int i = 0; i &lt; kNumThreads; ++i) {
    thread_ids[i] = i;
    int rt = pthread_create(&amp;threads[i], &amp;attr, ThreadProc,
                            static_cast&lt;void *&gt;(&amp;thread_ids[i]));
    if (rt) {
      printf(&quot;ERROR: pthread_create failed, rt=%d\n&quot;, rt);
      exit(1);
    }
  }
  pthread_exit(NULL);
  pthread_attr_destroy(&amp;attr);
  return 0;
}
</code></pre>
<h3 id="thread-attribute上文中未提到的">Thread Attribute(上文中未提到的)</h3>
<h4 id="api-4">API</h4>
<pre><code>typedef union
{
char __size[__SIZEOF_PTHREAD_ATTR_T];
long int __align;
}pthread_attr_t;

int pthread_attr_setscope(pthread_attr_t *attr, int scope);
//功能：设置线程属性中线程的竞争范围
//PTHREAD_SCOPE_SYSTEM(绑定)
//PTHREAD_SCOPE_PROCESS(非绑定)
int pthread_attr_getscope(pthread_attr_t *attr, int *scope);
//功能：获取线程属性中线程的竞争范围
</code></pre>
<p>关于绑定属性，涉及到另外一个概念：轻进程（Light Weight Process，LWP）。轻进程可以理解为内核进程，它位于用户层和内核层之间。系统对线程资源的分配和对线程的控制时通过轻进程来实现的，一个轻进程可以控制一个或多个线程。默认情况下，启动多少轻进程、哪些轻进程来控制哪些线程是由系统来控制的，这种状况即称为非绑定。绑定状况下，则顾名思义，即某个线程固定地绑在一个轻进程之上。被绑定的线程具有较高的响应速度，这是因为CPU时间片的调度是面向轻进程的，绑定的线程可以保证在需要的时候它总有一个轻进程可用。通过设置被绑定的轻进程的优先级和调度级可以使得绑定的线程满足诸如实时反应之类的要求。</p>
<pre><code>int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched);
//功能：设置线程属性中线程的调度策略来源
//PTHREAD_INHERIT_SCHED 继承创建者
//PTHREAD_EXPLICIT_SCHED 单独设置
int pthread_attr_getinheritsched(pthread_attr_t *attr, int *inheritsched);

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
//功能：设置线程属性中线程的调度策略
//SCHED_FIFO 先进先出策略
//SCHED_RR 轮转策略
//SCHED_OTHER 缺省
int pthread_attr_getschedpolicy(pthread_attr_t *attr, int *policy);
//功能：获取线程属性中线程的调度策略

struct sched_param {
int sched_priority;
}；
int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);
//功能：设置线程属性中线程的调度参数（优先级别）
//param：最高级别0
int pthread_attr_getschedparam(pthread_attr_t *attr, struct sched_param *param);
</code></pre>
<p>使用方法：</p>
<ol>
<li>定义线程属性结构体 pthread_attr_t attr;</li>
<li>初始化线程属性结构体 pthread_attr_init(&amp;attr);</li>
<li>使用pthread_attr_set系列函数对结构体变量进行设置。</li>
<li>在创建线程时（pthread_create函数的第二个参数）中使用线程属性结构变量创建线程。</li>
</ol>
<pre><code>pthread_t pthread_self(void);
int pthread_equal(pthread_t t1, pthread_t t2);
int pthread_once(pthread_once_t *once_control,
              void (*init_routine)(void));
pthread_once_t once_control = PTHREAD_ONCE_INIT;
</code></pre>
<ul>
<li><code>pthread_self</code> 返回调用线程的唯一 thread ID.</li>
<li><code>pthread_equal</code> 比较两个线程 ID 是否相等.</li>
<li><code>pthread_once</code> 本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。Linux Threads使用互斥锁和条件变量保证由pthread_once()指定的函数执行且仅执行一次，而once_control表示是否执行过。如果once_control的初值不是PTHREAD_ONCE_INIT（Linux Threads定义为0），pthread_once() 的行为就会不正常。在Linux中，实际&quot;一次性函数&quot;的执行状态有三种：NEVER（0）、IN_PROGRESS（1）、DONE （2），如果once初值设为1，则由于所有pthread_once()都必须等待其中一个激发&quot;已执行一次&quot;信号，因此所有pthread_once ()都会陷入永久的等待中；如果设为2，则表示该函数已执行过一次，从而所有pthread_once()都会立即返回0</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一篇博客]]></title>
        <id>https://wangpifu.github.io/post/first-blog/</id>
        <link href="https://wangpifu.github.io/post/first-blog/">
        </link>
        <updated>2020-04-29T09:27:05.000Z</updated>
        <content type="html"><![CDATA[<p>这是一篇建立在github pages，用Gridea构建管理的私人博客站点。目前来看Gridea是最方便的搭建管理软件，避免了安装nodejs 或者 ruby。 这对于Windows系统非常方便。坦白来讲，我并不希望在我的Windows box上安装任何和技术开发相关的软件，因为他们的使用频率很低，最终会被我遗忘在漫长的时光里。而我的开发机器（based on linux），我又希望它能只承载和开发相关的事务。另外，Gridea看起来更加直观与人性化，避免了许多与写作不相关的操作。希望Gridea可以一直被维护下去，感谢Gridea。cnblog本来是我的第一选择，但是需要手机号注册。CSDN则有太多的广告。知乎的话，我更倾向于发布仔细审视后的文章。这个站点则会更随意一些，有些想法我可以先记载下来，在日后慢慢的更改完善。</p>
<p>写博客的动力来自于一次失败的面试。我意识到很多技术的积累不能光靠工作，以及需要了解平时工作下的更深入的东西。人必须要不断地走出舒适圈，去接触自己不熟悉的东西，再能慢慢变得全能起来。我是一个不喜欢走在科技前端的人，平时更倾向于利用纸笔做笔记，但是现在意识到对于代码来讲，博客可能是个更合适的地方。对于刚开始的几篇文章，发布的频率可能比较高，内容可能不够精细，因为我希望能提纲挈领地把一些我在脑海中总结过的知识转移到这个站点上来，会在随后的日子里慢慢打磨。另外，我此时迫不及待地希望我能把一些需要学习的知识点电子化的记录下来，这也会导致初期一些文章显得杂乱。</p>
<p>希望明天会更好。<br>
--20200429 阴天 纽约</p>
]]></content>
    </entry>
</feed>